## 【Day 14】100. 相同的树

https://leetcode-cn.com/problems/same-tree/

* [题目描述](https://github.com/ZhangNN2018/91alg/blob/main/Basic/array_stack_queue/%E3%80%90Day%205%E3%80%91232.%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.md#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0)
* [方法](https://github.com/ZhangNN2018/91alg/blob/main/Basic/array_stack_queue/%E3%80%90Day%205%E3%80%91232.%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.md#%E6%96%B9%E6%B3%95)
     * [思路](https://github.com/ZhangNN2018/91alg/blob/main/Basic/array_stack_queue/%E3%80%90Day%205%E3%80%91232.%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.md#%E6%80%9D%E8%B7%AF)
     * [复杂度](https://github.com/ZhangNN2018/91alg/blob/main/Basic/array_stack_queue/%E3%80%90Day%205%E3%80%91232.%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.md#%E5%A4%8D%E6%9D%82%E5%BA%A6)
     * [代码](https://github.com/ZhangNN2018/91alg/blob/main/Basic/array_stack_queue/%E3%80%90Day%205%E3%80%91232.%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.md#%E4%BB%A3%E7%A0%81)
* [特别注意](https://github.com/ZhangNN2018/91alg/blob/main/Basic/array_stack_queue/%E3%80%90Day%205%E3%80%91232.%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.md#%E7%89%B9%E5%88%AB%E6%B3%A8%E6%84%8F)

### 题目描述
    给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。
    如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。


    示例 1：
![image](https://user-images.githubusercontent.com/39880430/147375074-c65cbfef-ff7b-4a1f-85d1-0db379cb2d46.png)


    输入：p = [1,2,3], q = [1,2,3]
    输出：true
    示例 2：
![image](https://user-images.githubusercontent.com/39880430/147375076-94c03651-9a49-430a-bfb4-b1c2fb65b82f.png)


    输入：p = [1,2], q = [1,null,2]
    输出：false
    示例 3：

![image](https://user-images.githubusercontent.com/39880430/147375080-07537e43-678c-4622-95cd-7cfee13bdd0b.png)

    输入：p = [1,2,1], q = [1,1,2]
    输出：false

    提示：
    两棵树上的节点数目都在范围 [0, 100] 内
    -104 <= Node.val <= 104

    来源：力扣（LeetCode）
    链接：https://leetcode-cn.com/problems/same-tree
    著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 方法

#### 思路
* 递归

#### 复杂度
* 时间复杂度: `O(N)` ,N为两棵树的最小节点数；
* 空间复杂度: `O(N)`。

#### 代码
```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def isSameTree(self, p, q):
        """
        :type p: TreeNode
        :type q: TreeNode
        :rtype: bool
        """
        if not p and not q: #同时为空，true
            return True
        if not p or not q: #有一个先空了，false
            return False
        if p.val != q.val: #都没空，但值不等，false
            return False
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right,q.right)
```
### 特别注意
* 左右子树分别递归
* 注意边界条件

